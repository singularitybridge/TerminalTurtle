--- Folder Structure ---
README.md
package.json
[src]
    ‚îú‚îÄ‚îÄ [executor]
        ‚îú‚îÄ‚îÄ commandExecutor.ts
        ‚îú‚îÄ‚îÄ fileManager.ts
        ‚îî‚îÄ‚îÄ taskManager.ts
    ‚îú‚îÄ‚îÄ main.ts
    ‚îú‚îÄ‚îÄ [server]
        ‚îú‚îÄ‚îÄ apiServer.ts
        ‚îú‚îÄ‚îÄ [handlers]
            ‚îú‚îÄ‚îÄ agentInfo.ts
            ‚îú‚îÄ‚îÄ changeDirectory.ts
            ‚îú‚îÄ‚îÄ endTask.ts
            ‚îú‚îÄ‚îÄ execute.ts
            ‚îú‚îÄ‚îÄ fileOperation.ts
            ‚îú‚îÄ‚îÄ getAllTasks.ts
            ‚îú‚îÄ‚îÄ healthCheck.ts
            ‚îî‚îÄ‚îÄ taskStatus.ts
        ‚îî‚îÄ‚îÄ [middleware]
            ‚îî‚îÄ‚îÄ auth.ts
    ‚îî‚îÄ‚îÄ [utils]
        ‚îú‚îÄ‚îÄ clientDirectories.ts
        ‚îú‚îÄ‚îÄ credentials.ts
        ‚îú‚îÄ‚îÄ logging.ts
        ‚îú‚îÄ‚îÄ ngrok.ts
        ‚îî‚îÄ‚îÄ security.ts

--- File Contents ---

--- File: README.md ---
# üê¢ TerminalTurtle

TerminalTurtle is an open-source developer tool that provides secure terminal automation and remote command execution capabilities. It's designed to be easy to use, secure, and flexible for modern development workflows.

## üöÄ Features

- **üîí Secure Command Execution**: Execute shell commands with output capture and proper security controls
- **üìÅ File Management**: List, create, read, update, and delete files with ease
- **üõ†Ô∏è Code Execution**: Write and execute code through a clean API interface
- **üåê REST API**: Modern RESTful API for all operations
- **üîó Optional Public URL**: Configure ngrok integration through environment variables
- **‚öôÔ∏è Easy Configuration**: Simple environment variable setup
- **üóÇÔ∏è Recursive File Operations**: Comprehensive file system operations
- **üê≥ Docker Support**: Ready-to-use Docker and Docker Compose setup
- **üñ•Ô∏è Per-Client Working Directory**: Maintain separate working directories for each client

## üèÅ Quick Start

[... existing content ...]

## üîß Configuration

[... existing content ...]

## üì° API Usage

### Command Execution

```bash
curl -X POST http://localhost:8080/execute \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_api_key" \
  -d '{"command": "echo Hello World"}'
```

### File Operations

```bash
# List files
curl -X POST http://localhost:8080/file-operation \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_api_key" \
  -d '{"operation": "list", "path": "./", "recursive": true}'

# Read file
curl -X POST http://localhost:8080/file-operation \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_api_key" \
  -d '{"operation": "read", "path": "./README.md"}'

# Write file
curl -X POST http://localhost:8080/file-operation \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_api_key" \
  -d '{"operation": "write", "path": "./test.txt", "content": "Hello!"}'
```

### Change Working Directory

```bash
curl -X POST http://localhost:8080/change-directory \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_api_key" \
  -d '{"newPath": "path/to/new/directory"}'
```

## üñ•Ô∏è Per-Client Working Directory Management

TerminalTurtle now supports per-client working directory management. This feature allows each client to have its own working directory, which persists across multiple command executions.

Key points:
- Each client (identified by their API key) has its own working directory.
- The working directory can be changed using the `/change-directory` endpoint.
- All file operations and command executions for a client will use their specific working directory.
- If a client hasn't set a working directory, the base working directory is used.

Usage:
1. Change the working directory using the `/change-directory` endpoint.
2. Execute commands or perform file operations as usual - they will now use the new working directory.
3. The working directory persists across multiple requests for the same client.

Security note: Clients can only set working directories within the base working directory specified in the server configuration.

[... rest of the existing content ...]


--- File: package.json ---
{
  "name": "terminal-turtle",
  "version": "1.0.0",
  "main": "dist/main.js",
  "directories": {
    "test": "tests"
  },
  "scripts": {
    "start": "node dist/main.js",
    "build": "tsc",
    "dev": "cross-env NODE_ENV=development nodemon --watch 'src/**/*.ts' --exec 'ts-node' src/main.ts",
    "test": "jest",
    "lint": "eslint . --ext .ts",
    "generate-credentials": "ts-node scripts/generateCredentials.ts"
  },
  "keywords": [
    "terminal",
    "automation",
    "developer-tools",
    "cli",
    "typescript",
    "docker",
    "api",
    "devops"
  ],
  "author": "SingularityBridge",
  "license": "MIT",
  "description": "TerminalTurtle: A developer-friendly tool for secure terminal automation and remote command execution",
  "repository": {
    "type": "git",
    "url": "https://github.com/singularitybridge/TerminalTurtle"
  },
  "bugs": {
    "url": "https://github.com/singularitybridge/TerminalTurtle/issues"
  },
  "dependencies": {
    "@types/axios": "^0.14.4",
    "@types/node": "^22.5.3",
    "axios": "^1.7.7",
    "cross-env": "^7.0.3",
    "dotenv": "^16.4.5",
    "express": "^4.18.2",
    "ngrok": "^5.0.0-beta.2",
    "node-pty": "^1.0.0",
    "strip-ansi": "^6.0.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.5.4",
    "uuid": "^10.0.0",
    "winston": "^3.12.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.14",
    "@types/supertest": "^6.0.2",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.57.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.1",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5"
  },
  "nodemonConfig": {
    "ignore": [
      "**/*.test.ts",
      "**/*.spec.ts",
      ".git",
      "node_modules"
    ],
    "watch": [
      "src"
    ],
    "exec": "ts-node",
    "ext": "ts"
  }
}


--- File: src/executor/commandExecutor.ts ---
import * as pty from 'node-pty';
import stripAnsi from 'strip-ansi';

const DEFAULT_TIMEOUT = 5 * 60 * 1000;

const createTimeout = (ptyProcess: pty.IPty): Promise<never> =>
  new Promise((_, reject) =>
    setTimeout(() => {
      ptyProcess.kill();
      reject(new Error(`Command timed out after ${DEFAULT_TIMEOUT}ms`));
    }, DEFAULT_TIMEOUT)
  );

export const executeCommand = async (
  command: string,
  workingDirectory: string,
  streamCallback?: (data: string) => void
): Promise<{
  success: boolean;
  output: string;
  exitCode: number;
  timedOut?: boolean;
}> => {
  try {
    const ptyProcess = pty.spawn('bash', ['-c', command], {
      name: 'xterm-color',
      cols: 80,
      rows: 30,
      cwd: workingDirectory,
      env: {
        ...process.env,
        FORCE_COLOR: '1',
        TERM: 'xterm-256color',
        GIT_TERMINAL_PROMPT: '1',
      },
    });

    let output = '';

    const execPromise = new Promise<{ exitCode: number }>((resolve) => {
      ptyProcess.onData((data) => {
        output += data;
        if (streamCallback) {
          streamCallback(stripAnsi(data));
        }
      });

      ptyProcess.onExit(({ exitCode }) => {
        resolve({ exitCode: exitCode ?? -1 });
      });
    });

    const { exitCode } = await Promise.race([execPromise, createTimeout(ptyProcess)]);

    const cleanOutput = stripAnsi(output);

    return {
      success: exitCode === 0,
      output: cleanOutput,
      exitCode,
    };
  } catch (error) {
    const err = error as any;

    if (err.message && err.message.includes('Command timed out')) {
      return {
        success: false,
        output: `Command terminated: ${err.message}`,
        exitCode: 124,
        timedOut: true,
      };
    }

    const output = stripAnsi(err.output || err.message || 'Unknown error occurred');

    return {
      success: false,
      output,
      exitCode: err.code || -1,
    };
  }
};


--- File: src/executor/fileManager.ts ---
import fs from 'fs/promises';
import { constants } from 'fs';
import path from 'path';
import { logger } from '../utils/logging';

/**
 * Recursively list all files in a directory.
 */
const listFilesRecursive = async (dir: string): Promise<string[]> => {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map(async (entry) => {
      const res = path.resolve(dir, entry.name);
      return entry.isDirectory() ? listFilesRecursive(res) : res;
    })
  );
  return files.flat();
};

/**
 * List files in a directory.
 */
export const listFiles = async (
  fullPath: string,
  recursive: boolean = false
): Promise<string[]> => {
  logger.info(`Listing files in ${fullPath}`);
  try {
    if (recursive) {
      return await listFilesRecursive(fullPath);
    } else {
      const entries = await fs.readdir(fullPath);
      return entries.map((entry) => path.join(fullPath, entry));
    }
  } catch (error: unknown) {
    logger.error(
      `Error listing files: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
    throw error;
  }
};

/**
 * Read the content of a file.
 */
export const readFile = async (fullPath: string): Promise<string> => {
  logger.info(`Reading file ${fullPath}`);
  try {
    return await fs.readFile(fullPath, 'utf-8');
  } catch (error: unknown) {
    logger.error(
      `Error reading file: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
    throw error;
  }
};

/**
 * Create a new file with specified content.
 * Throws an error if the file already exists.
 */
export const createFile = async (
  fullPath: string,
  content: string
): Promise<void> => {
  logger.info(`Creating file ${fullPath}`);
  try {
    await fs.writeFile(fullPath, content, { flag: 'wx', encoding: 'utf-8' });
  } catch (error: any) {
    if (error.code === 'EEXIST') {
      logger.error(`File already exists: ${fullPath}`);
      throw new Error('File already exists');
    } else {
      logger.error(
        `Error creating file: ${
          error instanceof Error ? error.message : 'Unknown error'
        }`
      );
      throw error;
    }
  }
};

/**
 * Write content to a file, overwriting existing content or creating a new file.
 */
export const writeFile = async (
  fullPath: string,
  content: string
): Promise<void> => {
  logger.info(`Writing to file ${fullPath}`);
  try {
    await fs.writeFile(fullPath, content, 'utf-8');
  } catch (error: unknown) {
    logger.error(
      `Error writing to file: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
    throw error;
  }
};

/**
 * Update an existing file's content with the specified mode.
 */
export const updateFile = async (
  fullPath: string,
  content: string,
  mode: 'overwrite' | 'append'
): Promise<void> => {
  logger.info(`Updating file ${fullPath} with mode ${mode}`);
  try {
    if (mode === 'overwrite') {
      await fs.writeFile(fullPath, content, 'utf-8');
    } else if (mode === 'append') {
      await fs.appendFile(fullPath, content, 'utf-8');
    } else {
      throw new Error('Invalid mode for updateFile. Use "overwrite" or "append".');
    }
  } catch (error: unknown) {
    logger.error(
      `Error updating file: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
    throw error;
  }
};

/**
 * Delete a specified file.
 */
export const deleteFile = async (fullPath: string): Promise<void> => {
  logger.info(`Deleting file ${fullPath}`);
  try {
    await fs.unlink(fullPath);
  } catch (error: unknown) {
    logger.error(
      `Error deleting file: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
    throw error;
  }
};

/**
 * Create a new directory.
 */
export const createDirectory = async (fullPath: string): Promise<void> => {
  logger.info(`Creating directory ${fullPath}`);
  try {
    await fs.mkdir(fullPath, { recursive: true });
  } catch (error: unknown) {
    logger.error(
      `Error creating directory: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
    throw error;
  }
};

/**
 * Delete a specified directory and its contents.
 */
export const deleteDirectory = async (fullPath: string): Promise<void> => {
  logger.info(`Deleting directory ${fullPath}`);
  try {
    await fs.rm(fullPath, { recursive: true, force: true });
  } catch (error: unknown) {
    logger.error(
      `Error deleting directory: ${
        error instanceof Error ? error.message : 'Unknown error'
      }`
    );
    throw error;
  }
};

/**
 * Check if a file or directory exists.
 */
export const checkExistence = async (fullPath: string): Promise<boolean> => {
  logger.info(`Checking existence of ${fullPath}`);
  try {
    await fs.access(fullPath, constants.F_OK);
    return true;
  } catch {
    return false;
  }
};


--- File: src/executor/taskManager.ts ---
import { v4 as uuidv4 } from 'uuid';

const MAX_OUTPUT_SIZE = 1024 * 1024; // 1 MB

interface Task {
  id: string;
  command: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  outputChunks: string[];
  exitCode: number | null;
  error: string | null;
  createdAt: Date;
  updatedAt: Date;
}

const tasks = new Map<string, Task>();

export const createTask = (command: string): Task => {
  const id = uuidv4();
  const task: Task = {
    id,
    command,
    status: 'pending',
    outputChunks: [],
    exitCode: null,
    error: null,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
  tasks.set(id, task);
  return task;
};

export const getTask = (id: string): Task | undefined => {
  return tasks.get(id);
};

export const updateTask = (id: string, updates: Partial<Omit<Task, 'outputChunks'>> & { output?: string }): void => {
  const task = tasks.get(id);
  if (task) {
    if (updates.output !== undefined) {
      const currentSize = task.outputChunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const availableSize = MAX_OUTPUT_SIZE - currentSize;
      
      if (availableSize > 0) {
        const newChunk = updates.output.slice(0, availableSize);
        task.outputChunks.push(newChunk);
      }
      
      delete updates.output;
    }
    
    Object.assign(task, updates);
    task.updatedAt = new Date();
  }
};

export const getTaskOutput = (id: string): string => {
  const task = tasks.get(id);
  return task ? task.outputChunks.join('') : '';
};

export const getAllTasks = (): Task[] => {
  return Array.from(tasks.values());
};

export const endTask = (id: string): boolean => {
  const task = tasks.get(id);
  if (task && (task.status === 'pending' || task.status === 'running')) {
    task.status = 'completed';
    task.updatedAt = new Date();
    return true;
  }
  return false;
};


--- File: src/main.ts ---
import dotenv from 'dotenv';
import path from 'path';
import fs from 'fs';
import { createApiServer } from './server/apiServer';
import { logger, setupUnhandledExceptionLogging } from './utils/logging';
import { AddressInfo } from 'net';
import { getCredentials } from './utils/credentials';
import { setupNgrok } from './utils/ngrok';
import { cleanupInactiveClientDirectories } from './utils/clientDirectories';

// Load environment variables from .env file if it exists
const envPath = path.resolve(__dirname, '../.env');
const result = dotenv.config({ path: envPath });

if (result.error) {
  // Check if error is a NodeJS.ErrnoException which has the 'code' property
  if ((result.error as NodeJS.ErrnoException).code !== 'ENOENT') {
    // Only exit if there's an error other than the file not existing
    console.error('Error loading .env file:', result.error);
    process.exit(1);
  } else {
    console.warn('No .env file found. Proceeding with environment variables.');
  }
}

// Default values
const DEFAULT_PORT = 3000;
const DEFAULT_WORKING_DIRECTORY = path.resolve(__dirname, '../working_directory');
const CLEANUP_INTERVAL = 3600000; // 1 hour in milliseconds
const INACTIVE_THRESHOLD = 86400000; // 24 hours in milliseconds

const PORT = process.env.PORT ? parseInt(process.env.PORT, 10) : DEFAULT_PORT;
const WORKING_DIRECTORY = process.env.WORKING_DIRECTORY || DEFAULT_WORKING_DIRECTORY;

if (!process.env.PORT) {
  logger.warn(`PORT not set in environment. Using default port: ${DEFAULT_PORT}`);
}

if (!process.env.WORKING_DIRECTORY) {
  logger.warn(`WORKING_DIRECTORY not set in environment. Using default: ${DEFAULT_WORKING_DIRECTORY}`);
}

setupUnhandledExceptionLogging();

const findAvailablePort = async (startPort: number): Promise<number> => {
  const net = require('net');
  
  return new Promise((resolve, reject) => {
    const server = net.createServer();
    
    server.on('error', (err: NodeJS.ErrnoException) => {
      if (err.code === 'EADDRINUSE') {
        // Try the next port
        server.listen(startPort + 1);
      } else {
        reject(err);
      }
    });

    server.listen(startPort, () => {
      const { port } = server.address() as AddressInfo;
      server.close(() => resolve(port));
    });
  });
};

const startServer = async (): Promise<void> => {
  logger.info(`Starting AI Agent Executor in ${process.env.NODE_ENV || 'development'} mode`);
  logger.info(`Configured working directory: ${WORKING_DIRECTORY}`);

  // Initialize agent credentials from environment variables
  try {
    const credentials = getCredentials();
    logger.info('Agent configured successfully', {
      agentId: credentials.id,
      name: credentials.name,
    });
  } catch (error) {
    logger.error('Error setting up agent credentials', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    process.exit(1);
  }

  try {
    if (!fs.existsSync(WORKING_DIRECTORY)) {
      logger.info(`Creating working directory: ${WORKING_DIRECTORY}`);
      fs.mkdirSync(WORKING_DIRECTORY, { recursive: true });
    } else {
      logger.info(`Working directory already exists: ${WORKING_DIRECTORY}`);
    }

    // Check if the directory is writable
    fs.accessSync(WORKING_DIRECTORY, fs.constants.W_OK);
    logger.info(`Working directory is writable: ${WORKING_DIRECTORY}`);
  } catch (error) {
    logger.error('Error with working directory', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    process.exit(1);
  }

  try {
    // Create API server
    const { start } = await createApiServer(WORKING_DIRECTORY);

    // Find an available port starting from the configured PORT
    const availablePort = await findAvailablePort(PORT);
    if (availablePort !== PORT) {
      logger.info(`Port ${PORT} was in use, using port ${availablePort} instead`);
    }

    // Start the server
    const server = await start(availablePort);

    // Setup ngrok after server starts
    const ngrokConnection = await setupNgrok(availablePort);

    // Set up periodic cleanup of inactive client directories
    setInterval(() => {
      cleanupInactiveClientDirectories(INACTIVE_THRESHOLD)
        .catch(error => {
          logger.error('Error during cleanup of inactive client directories', {
            error: error instanceof Error ? error.message : 'Unknown error',
          });
        });
    }, CLEANUP_INTERVAL);

    // Handle server errors
    server.on('error', (error: NodeJS.ErrnoException) => {
      if (error.code === 'EADDRINUSE') {
        logger.error(`Port ${availablePort} is already in use. Please try again in a few moments or use a different port.`);
      } else {
        logger.error('Server error', { error });
      }
      process.exit(1);
    });

    // Handle graceful shutdown
    process.on('SIGINT', async () => {
      logger.info('Shutting down AI Agent Executor');
      if (ngrokConnection) {
        await ngrokConnection.disconnect();
      }
      server.close(() => {
        process.exit(0);
      });
    });

  } catch (error) {
    logger.error('Failed to start server', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    process.exit(1);
  }
};

// Handle any unhandled promise rejections
process.on('unhandledRejection', (reason: unknown) => {
  logger.error('Unhandled Promise Rejection', {
    error: reason instanceof Error ? reason.message : 'Unknown error',
  });
});

startServer().catch((error: unknown) => {
  logger.error('Failed to start server', {
    error: error instanceof Error ? error.message : 'Unknown error',
  });
  process.exit(1);
});


--- File: src/server/apiServer.ts ---
import express from 'express';
import path from 'path';
import { Server } from 'http';
import { logger } from '../utils/logging';
import { setupNgrok } from '../utils/ngrok';
import { authenticateRequest } from './middleware/auth';
import { handleHealthCheck } from './handlers/healthCheck';
import { handleAgentInfo } from './handlers/agentInfo';
import { handleExecute } from './handlers/execute';
import { handleFileOperation } from './handlers/fileOperation';
import { handleTaskStatus } from './handlers/taskStatus';
import { handleChangeDirectory } from './handlers/changeDirectory';
import { handleGetAllTasks } from './handlers/getAllTasks';
import { handleEndTask } from './handlers/endTask';

export const createApiServer = async (workingDirectory: string): Promise<{ 
  app: express.Express, 
  start: (port: number) => Promise<Server>
}> => {
  const app = express();
  app.use(express.json());

  app.locals.baseWorkingDirectory = path.resolve(workingDirectory);

  // Public routes
  app.get('/health', handleHealthCheck);
  app.get('/agent-info', handleAgentInfo);

  // Protected routes
  app.use(['/execute', '/file-operation', '/tasks', '/change-directory'], authenticateRequest);
  app.post('/execute', handleExecute);
  app.post('/file-operation', handleFileOperation);
  app.get('/tasks', handleGetAllTasks);
  app.get('/tasks/:taskId', handleTaskStatus);
  app.post('/tasks/:taskId/end', handleEndTask);
  app.post('/change-directory', handleChangeDirectory);

  const start = async (port: number): Promise<Server> => {
    return new Promise((resolve, reject) => {
      const server = app.listen(port, async () => {
        logger.info(`AI Agent Executor is listening on port ${port}`);
        logger.info(`Base working directory: ${workingDirectory}`);

        const ngrokConnection = await setupNgrok(port);
        
        if (ngrokConnection) {
          server.on('close', async () => {
            logger.info('Server closing, cleaning up...');
            await ngrokConnection.disconnect();
          });
        }

        resolve(server);
      });

      server.on('error', (error: Error) => {
        reject(error);
      });
    });
  };

  return { app, start };
};


--- File: src/server/handlers/agentInfo.ts ---
import { Request, Response } from 'express';
import { getCredentials } from '../../utils/credentials';

export const handleAgentInfo = (_req: Request, res: Response): void => {
  try {
    const credentials = getCredentials();
    res.json({
      id: credentials.id,
      name: credentials.name,
    });
  } catch (error) {
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
};


--- File: src/server/handlers/changeDirectory.ts ---
import { Response } from 'express';
import path from 'path';
import fs from 'fs';
import { AuthenticatedRequest } from '../middleware/auth';
import { setClientWorkingDirectory } from '../../utils/clientDirectories';

export const handleChangeDirectory = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  const { newPath } = req.body;
  const clientId = req.agentId as string; // Type assertion to ensure clientId is a string

  if (!clientId) {
    res.status(401).json({ error: 'Unauthorized: Missing client ID' });
    return;
  }

  if (!newPath) {
    res.status(400).json({ error: 'newPath is required' });
    return;
  }

  const baseWorkingDirectory = req.app.locals.baseWorkingDirectory;
  const absolutePath = path.resolve(baseWorkingDirectory, newPath);

  // Security: Ensure the new path is within the base working directory
  if (!absolutePath.startsWith(baseWorkingDirectory)) {
    res.status(400).json({ error: 'Invalid directory path' });
    return;
  }

  // Check if the path exists and is a directory
  try {
    const stats = fs.statSync(absolutePath);
    if (!stats.isDirectory()) {
      res.status(400).json({ error: 'Path is not a directory' });
      return;
    }
  } catch (error) {
    res.status(400).json({ error: 'Directory does not exist' });
    return;
  }

  setClientWorkingDirectory(clientId, absolutePath);
  res.status(200).json({ message: `Working directory changed to ${absolutePath}` });
};


--- File: src/server/handlers/endTask.ts ---
import { Request, Response } from 'express';
import { endTask, getTask } from '../../executor/taskManager';

export const handleEndTask = async (req: Request, res: Response): Promise<void> => {
  const { taskId } = req.params;

  try {
    const task = getTask(taskId);
    if (!task) {
      res.status(404).json({ error: 'Task not found' });
      return;
    }

    const success = endTask(taskId);
    if (success) {
      res.json({ message: 'Task ended successfully', taskId });
    } else {
      res.status(400).json({ error: 'Task could not be ended. It may already be completed or failed.' });
    }
  } catch (error) {
    console.error('Error ending task:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};


--- File: src/server/handlers/execute.ts ---
import { Response } from 'express';
import { executeCommand } from '../../executor/commandExecutor';
import { logger } from '../../utils/logging';
import { AuthenticatedRequest } from '../middleware/auth';
import { createTask, updateTask, getTaskOutput } from '../../executor/taskManager';
import { getClientWorkingDirectory } from '../../utils/clientDirectories';

const INITIAL_RESPONSE_TIMEOUT = 10000; // 10 seconds

export const handleExecute = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  const { command } = req.body;
  const clientId = req.agentId as string;

  if (!clientId) {
    res.status(401).json({ error: 'Unauthorized: Missing client ID' });
    return;
  }

  // Get the client-specific working directory
  const baseWorkingDirectory = req.app.locals.baseWorkingDirectory;
  const workingDirectory = getClientWorkingDirectory(clientId, baseWorkingDirectory);

  // Create a new task
  const task = createTask(command);
  logger.info(`Created task ${task.id} for command: ${command}`);

  let commandCompleted = false;
  let initialOutputSent = false;

  const executionPromise = executeCommand(
    command,
    workingDirectory,
    (data: string) => {
      updateTask(task.id, { output: data });
    }
  );

  const timeoutPromise = new Promise<void>((resolve) => {
    setTimeout(() => {
      if (!commandCompleted && !initialOutputSent) {
        initialOutputSent = true;
        const initialOutput = getTaskOutput(task.id);
        res.json({ taskId: task.id, initialOutput });
      }
      resolve();
    }, INITIAL_RESPONSE_TIMEOUT);
  });

  try {
    const result = await Promise.race([executionPromise, timeoutPromise]);

    if (result) {
      // Command completed before timeout
      commandCompleted = true;
      updateTask(task.id, {
        status: 'completed',
        exitCode: result.exitCode,
        output: result.output,
      });

      if (!initialOutputSent) {
        // Command completed within 10 seconds, send final response
        res.json({
          output: result.output,
          exitCode: result.exitCode,
          completed: true,
        });
      }

      logger.info(`Task ${task.id} completed with exit code ${result.exitCode}`);
    } else if (!initialOutputSent) {
      // Timeout occurred, but response wasn't sent (rare case)
      const initialOutput = getTaskOutput(task.id);
      res.json({ taskId: task.id, initialOutput });
    }

    // If initial output was sent, continue execution in the background
    if (initialOutputSent && !commandCompleted) {
      executionPromise.then((result) => {
        updateTask(task.id, {
          status: 'completed',
          exitCode: result.exitCode,
          output: result.output,
        });
        logger.info(`Task ${task.id} completed with exit code ${result.exitCode}`);
      }).catch((error) => {
        const err = error as Error;
        updateTask(task.id, {
          status: 'failed',
          error: err.message,
        });
        logger.error(`Task ${task.id} failed: ${err.message}`);
      });
    }
  } catch (error) {
    const err = error as Error;
    updateTask(task.id, {
      status: 'failed',
      error: err.message,
    });

    if (!initialOutputSent) {
      res.status(500).json({ error: err.message });
    }

    logger.error(`Task ${task.id} failed: ${err.message}`);
  }
};


--- File: src/server/handlers/fileOperation.ts ---
import { Response } from 'express';
import path from 'path';
import {
  listFiles,
  readFile,
  writeFile,
  createFile,
  updateFile,
  deleteFile,
  createDirectory,
  deleteDirectory,
  checkExistence,
} from '../../executor/fileManager';
import { logger } from '../../utils/logging';
import { AuthenticatedRequest } from '../middleware/auth';
import { getClientWorkingDirectory } from '../../utils/clientDirectories';

const performFileOperation = async (workingDirectory: string, req: any): Promise<any> => {
  const { operation, path: relativePath, content, recursive, mode } = req;
  const fullPath = path.resolve(workingDirectory, relativePath);

  logger.info(`Performing ${operation} on ${fullPath}`);

  switch (operation) {
    case 'list': return await listFiles(fullPath, recursive);
    case 'read': return await readFile(fullPath);
    case 'write':
      if (content === undefined) throw new Error('Content is required for write operation');
      await writeFile(fullPath, content);
      return 'File written successfully';
    case 'createFile':
      if (content === undefined) throw new Error('Content is required for createFile operation');
      await createFile(fullPath, content);
      return 'File created successfully';
    case 'update':
      if (content === undefined || mode === undefined) throw new Error('Content and mode are required for update operation');
      await updateFile(fullPath, content, mode);
      return 'File updated successfully';
    case 'deleteFile':
      await deleteFile(fullPath);
      return 'File deleted successfully';
    case 'createDir':
      await createDirectory(fullPath);
      return 'Directory created successfully';
    case 'deleteDirectory':
      await deleteDirectory(fullPath);
      return 'Directory deleted successfully';
    case 'checkExistence':
      const exists = await checkExistence(fullPath);
      return { exists };
    default:
      throw new Error('Invalid file operation');
  }
};

export const handleFileOperation = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  const clientId = req.agentId as string;

  if (!clientId) {
    res.status(401).json({ error: 'Unauthorized: Missing client ID' });
    return;
  }

  try {
    const baseWorkingDirectory = req.app.locals.baseWorkingDirectory;
    const workingDirectory = getClientWorkingDirectory(clientId, baseWorkingDirectory);
    const result = await performFileOperation(workingDirectory, req.body);
    res.json({ result });
  } catch (error) {
    logger.error('Error performing file operation', {
      error,
      request: req.body,
      agentId: clientId,
    });
    if (error instanceof Error && error.message === 'File or directory not found') {
      res.status(404).json({ error: 'File or directory not found' });
    } else {
      res.status(500).json({
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      });
    }
  }
};


--- File: src/server/handlers/getAllTasks.ts ---
import { Request, Response } from 'express';
import { getAllTasks } from '../../executor/taskManager';

export const handleGetAllTasks = async (req: Request, res: Response): Promise<void> => {
  try {
    const tasks = await getAllTasks();
    res.json(tasks);
  } catch (error) {
    console.error('Error getting all tasks:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};


--- File: src/server/handlers/healthCheck.ts ---
import { Request, Response } from 'express';

export const handleHealthCheck = (_req: Request, res: Response): void => {
  res.status(200).json({ status: 'healthy' });
};


--- File: src/server/handlers/taskStatus.ts ---
import { Response } from 'express';
import { logger } from '../../utils/logging';
import { AuthenticatedRequest } from '../middleware/auth';
import { getTask, getTaskOutput } from '../../executor/taskManager';

export const handleTaskStatus = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  const { taskId } = req.params;
  const task = getTask(taskId);

  if (!task) {
    res.status(404).json({ error: 'Task not found' });
    return;
  }

  res.status(200).json({
    id: task.id,
    command: task.command,
    status: task.status,
    output: getTaskOutput(task.id),
    exitCode: task.exitCode,
    error: task.error,
    createdAt: task.createdAt,
    updatedAt: task.updatedAt,
  });
};


--- File: src/server/middleware/auth.ts ---
import { Request, Response, NextFunction } from 'express';
import { getCredentials } from '../../utils/credentials';
import { logger } from '../../utils/logging';

export interface AuthenticatedRequest extends Request {
  agentId?: string;
}

export const authenticateRequest = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): void => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    res.status(401).json({ error: 'Missing or invalid authorization header' });
    return;
  }

  try {
    const credentials = getCredentials();
    const providedApiKey = authHeader.split(' ')[1];

    if (providedApiKey !== credentials.apiKey) {
      res.status(401).json({ error: 'Invalid API key' });
      return;
    }

    req.agentId = credentials.id;
    next();
  } catch (error) {
    logger.error('Authentication error', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    res.status(500).json({ error: 'Internal server error' });
  }
};


--- File: src/utils/clientDirectories.ts ---
import path from 'path';
import fs from 'fs/promises';
import { logger } from './logging';

const clientWorkingDirectories = new Map<string, string>();

/**
 * Sets the working directory for a specific client.
 * @param clientId The unique identifier for the client.
 * @param newPath The new working directory path for the client.
 */
export const setClientWorkingDirectory = (clientId: string, newPath: string): void => {
  try {
    clientWorkingDirectories.set(clientId, newPath);
    logger.info(`Set working directory for client ${clientId} to ${newPath}`);
  } catch (error) {
    logger.error(`Failed to set working directory for client ${clientId}`, error);
  }
};

/**
 * Retrieves the working directory for a specific client.
 * If no directory is set for the client, it returns the base working directory.
 * @param clientId The unique identifier for the client.
 * @param baseWorkingDirectory The default base working directory.
 * @returns The client's working directory or the base working directory.
 */
export const getClientWorkingDirectory = (clientId: string, baseWorkingDirectory: string): string => {
  try {
    const clientDir = clientWorkingDirectories.get(clientId);
    if (clientDir) {
      logger.debug(`Retrieved working directory for client ${clientId}: ${clientDir}`);
      return clientDir;
    }
    logger.debug(`Using base working directory for client ${clientId}: ${baseWorkingDirectory}`);
    return baseWorkingDirectory;
  } catch (error) {
    logger.error(`Failed to get working directory for client ${clientId}`, error);
    return baseWorkingDirectory;
  }
};

/**
 * Resets the working directory for a specific client to the default.
 * @param clientId The unique identifier for the client.
 */
export const resetClientWorkingDirectory = (clientId: string): void => {
  try {
    clientWorkingDirectories.delete(clientId);
    logger.info(`Reset working directory for client ${clientId}`);
  } catch (error) {
    logger.error(`Failed to reset working directory for client ${clientId}`, error);
  }
};

/**
 * Cleans up inactive client directories.
 * This function should be called periodically to remove directories for inactive clients.
 * @param inactiveThreshold The time in milliseconds after which a client is considered inactive.
 */
export const cleanupInactiveClientDirectories = async (inactiveThreshold: number): Promise<void> => {
  const now = Date.now();
  for (const [clientId, directory] of clientWorkingDirectories.entries()) {
    try {
      const stats = await fs.stat(directory);
      if (now - stats.atimeMs > inactiveThreshold) {
        resetClientWorkingDirectory(clientId);
        logger.info(`Cleaned up inactive directory for client ${clientId}`);
      }
    } catch (error) {
      logger.error(`Failed to check or clean up directory for client ${clientId}`, error);
    }
  }
};


--- File: src/utils/credentials.ts ---
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';

interface AgentCredentials {
  id: string;
  apiKey: string;
  name?: string;
}

const generateApiKey = (): string => {
  return crypto.randomBytes(32).toString('hex');
};

const generateCredentials = (name?: string): AgentCredentials => {
  const credentials: AgentCredentials = {
    id: uuidv4(),
    apiKey: generateApiKey(),
    name: name || 'terminal-turtle',
  };
  return credentials;
};

const getCredentials = (): AgentCredentials => {
  const id = process.env.AGENT_ID;
  const apiKey = process.env.API_KEY;
  const name = process.env.AGENT_NAME || 'terminal-turtle';

  if (!id || !apiKey) {
    throw new Error('AGENT_ID and API_KEY must be provided in environment variables.');
  }

  return { id, apiKey, name };
};

export {
  generateCredentials,
  getCredentials,
  type AgentCredentials,
};


--- File: src/utils/logging.ts ---
import { createLogger, transports, format } from 'winston';

export const logger = createLogger({
  level: 'info',
  format: format.combine(
    // format.timestamp(),
    format.errors({ stack: true }),
    format.splat(),
    format.json()
  ),
  transports: [
    new transports.Console({
      format: format.combine(format.colorize(), format.simple()),
    }),
    new transports.File({ filename: 'app.log' }),
  ],
});

export const setupUnhandledExceptionLogging = (): void => {
  process.on('uncaughtException', (error) => {
    logger.error('Uncaught Exception', error);
  });

  process.on('unhandledRejection', (reason) => {
    logger.error('Unhandled Rejection', reason);
  });
};


--- File: src/utils/ngrok.ts ---
import ngrok from 'ngrok';
import { logger } from './logging';

interface NgrokConnection {
  url: string;
  disconnect: () => Promise<void>;
}

export const setupNgrok = async (port: number): Promise<NgrokConnection | null> => {
  const enableNgrok = process.env.ENABLE_NGROK === 'true';
  const authtoken = process.env.NGROK_AUTHTOKEN;

  if (!enableNgrok) {
    logger.info('Ngrok is not enabled. Set ENABLE_NGROK=true in your .env file to enable it.');
    return null;
  }

  if (!authtoken) {
    logger.warn('Ngrok auth token is not provided. Set NGROK_AUTHTOKEN in your .env file to use ngrok.');
    return null;
  }

  try {
    logger.info('Starting ngrok tunnel...', { port });

    const url = await ngrok.connect({
      addr: port,
      authtoken,
    });

    logger.info('Ngrok tunnel established', { url });

    return {
      url,
      disconnect: async () => {
        try {
          await ngrok.disconnect(url);
          await ngrok.kill();
          logger.info('Ngrok tunnel disconnected');
        } catch (error) {
          logger.error('Error disconnecting ngrok tunnel', { 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        }
      }
    };
  } catch (error) {
    logger.error('Error establishing ngrok tunnel', { 
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    return null;
  }
};


--- File: src/utils/security.ts ---
import { logger } from './logging';

export const isCommandWhitelisted = (command: string): boolean => {
  // For testing purposes, allow all commands
  logger.info(`Allowing command: ${command}`);
  return true;
};

export const sanitizeInput = (input: string): string => {
  // Optionally, implement input sanitization if needed
  return input;
};

export const rateLimiter = (() => {
  // For testing purposes, disable rate limiting
  return (_clientId: string): boolean => {
    return true;
  };
})();

export const authenticate = (token: string): boolean => {
  // For testing purposes, bypass authentication
  return true;
};

